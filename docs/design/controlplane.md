# Control Plane

The control plane consists of a single controller that runs within the Kubernetes cluster.

## Monitors Key Resources

The controller uses informers to watch for changes to key resources. When a change is detected, it triggers a reconciliation of the appropriate `Gateway` resource(s). The reconciliation logic is as follows:

-   **`GatewayClass`**: The controller watches `GatewayClass` resources to identify which one it is responsible for (by matching `spec.controllerName`). On add or update, it updates the `GatewayClass` status to mark it as "Accepted".
-   **`Gateway`**: A change to a `Gateway` directly enqueues that same `Gateway` for reconciliation. This is the primary trigger for creating, updating, or deleting an Envoy proxy and its configuration.
-   **`HTTPRoute`**: When an `HTTPRoute` is added, updated, or deleted, the controller inspects its `spec.parentRefs` and enqueues each referenced `Gateway` for reconciliation.
-   **`XBackend`**: A change to an `XBackend` triggers a more complex discovery process. The controller finds all `HTTPRoute`s that reference the `XBackend`, and then finds all `Gateway`s referenced by those `HTTPRoute`s, enqueuing them for reconciliation.
-   **`XAccessPolicy`**: A change to an `XAccessPolicy` follows a similar chain. The controller identifies the `XBackend`(s) targeted by the policy and then triggers the same `XBackend` reconciliation logic to find and enqueue the affected `Gateway`(s).
-   **`Service`**: The controller watches for `Service` changes, as they can affect the endpoints for an `XBackend`. A change will trigger reconciliation of any `Gateway` that routes to a `Backend` using that `Service`.

The controller uses listers for `Secret`, `ServiceAccount`, and `Namespace` resources during the reconciliation of a `Gateway`, but it does not currently watch them to trigger reconciliations directly.

## Manages Envoy Proxy Lifecycle

For each `Gateway` resource that is associated with its `GatewayClass`, the controller automatically provisions and manages a dedicated Envoy proxy instance within the `Gateway`'s namespace. This includes:

- **Service Account**: A dedicated `ServiceAccount` for the Envoy proxy pod.
- **ConfigMap**: A `ConfigMap` containing the Envoy bootstrap configuration. This configuration tells Envoy how to connect to the control plane's xDS server.
- **Deployment**: A `Deployment` that manages the Envoy proxy pod. The resource name is deterministic, generated by hashing the `Gateway`'s namespace and name (e.g., `envoy-proxy-<hash>`).
- **Service**: A `ClusterIP` `Service` that exposes the Envoy proxy `Deployment` to other pods in the cluster on the ports defined by the `Gateway` listeners.

When a `Gateway` resource is deleted, the controller performs a cleanup, deleting the corresponding `Deployment`, `Service`, `ConfigMap`, and `ServiceAccount`.

## Dynamic Policy Enforcement via xDS

The controller translates the high-level Kubernetes resources into a low-level Envoy configuration. This configuration is then served to the appropriate Envoy proxy via the xDS protocol.

- **xDS Server**: The controller runs a gRPC server that implements the Envoy xDS APIs (LDS, RDS, CDS, etc.). This server is exposed within the cluster via a `ClusterIP` service named `agentic-net-xds-server` in the `agentic-net-system` namespace.
- **Translation**: When a `Gateway` is reconciled, the controller reads all associated `HTTPRoute`, `XBackend`, and `XAccessPolicy` resources. It translates this collection of resources into a coherent set of Envoy Listeners, Route Configurations, Clusters, and RBAC rules.
- **Configuration Push**: The generated configuration is pushed to the specific Envoy proxy identified by its unique Node ID (e.g., `envoy-proxy-<hash>`). This ensures that each Envoy proxy only receives the configuration relevant to the `Gateway` it represents.
